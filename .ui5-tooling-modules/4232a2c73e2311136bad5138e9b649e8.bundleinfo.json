{
  "_entries": [
    {
      "name": "reselect",
      "path": "C:\\Users\\Adrians\\Documents\\sapui5_apps\\sapui5_redux_github\\sapui5_Redux\\node_modules\\reselect\\dist\\reselect.mjs",
      "lastModified": 1747209312198,
      "type": "module",
      "originalName": "reselect",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  // src/devModeChecks/identityFunctionCheck.ts\n\n  // src/devModeChecks/setGlobalDevModeChecks.ts\n  var globalDevModeChecks = {\n    inputStabilityCheck: \"once\",\n    identityFunctionCheck: \"once\"\n  };\n  var setGlobalDevModeChecks = (devModeChecks) => {\n    Object.assign(globalDevModeChecks, devModeChecks);\n  };\n\n  // src/utils.ts\n  var NOT_FOUND = /* @__PURE__ */ Symbol(\"NOT_FOUND\");\n  function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\n    if (typeof func !== \"function\") {\n      throw new TypeError(errorMessage);\n    }\n  }\n  function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\n    if (typeof object !== \"object\") {\n      throw new TypeError(errorMessage);\n    }\n  }\n  function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\n    if (!array.every((item) => typeof item === \"function\")) {\n      const itemTypes = array.map(\n        (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\n      ).join(\", \");\n      throw new TypeError(`${errorMessage}[${itemTypes}]`);\n    }\n  }\n  var ensureIsArray = (item) => {\n    return Array.isArray(item) ? item : [item];\n  };\n  function getDependencies(createSelectorArgs) {\n    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n    assertIsArrayOfFunctions(\n      dependencies,\n      `createSelector expects all input-selectors to be functions, but received the following types: `\n    );\n    return dependencies;\n  }\n  function collectInputSelectorResults(dependencies, inputSelectorArgs) {\n    const inputSelectorResults = [];\n    const { length } = dependencies;\n    for (let i = 0; i < length; i++) {\n      inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n    }\n    return inputSelectorResults;\n  }\n\n  // src/autotrackMemoize/autotracking.ts\n  var $REVISION = 0;\n  var CURRENT_TRACKER = null;\n  var Cell = class {\n    revision = $REVISION;\n    _value;\n    _lastValue;\n    _isEqual = tripleEq;\n    constructor(initialValue, isEqual = tripleEq) {\n      this._value = this._lastValue = initialValue;\n      this._isEqual = isEqual;\n    }\n    // Whenever a storage value is read, it'll add itself to the current tracker if\n    // one exists, entangling its state with that cache.\n    get value() {\n      CURRENT_TRACKER?.add(this);\n      return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    set value(newValue) {\n      if (this.value === newValue)\n        return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  };\n  function tripleEq(a, b) {\n    return a === b;\n  }\n  var TrackingCache = class {\n    _cachedValue;\n    _cachedRevision = -1;\n    _deps = [];\n    hits = 0;\n    fn;\n    constructor(fn) {\n      this.fn = fn;\n    }\n    clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n    get value() {\n      if (this.revision > this._cachedRevision) {\n        const { fn } = this;\n        const currentTracker = /* @__PURE__ */ new Set();\n        const prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n      CURRENT_TRACKER?.add(this);\n      return this._cachedValue;\n    }\n    get revision() {\n      return Math.max(...this._deps.map((d) => d.revision), 0);\n    }\n  };\n  function getValue(cell) {\n    if (!(cell instanceof Cell)) {\n      console.warn(\"Not a valid cell! \", cell);\n    }\n    return cell.value;\n  }\n  function setValue(storage, value) {\n    if (!(storage instanceof Cell)) {\n      throw new TypeError(\n        \"setValue must be passed a tracked store created with `createStorage`.\"\n      );\n    }\n    storage.value = storage._lastValue = value;\n  }\n  function createCell(initialValue, isEqual = tripleEq) {\n    return new Cell(initialValue, isEqual);\n  }\n  function createCache(fn) {\n    assertIsFunction(\n      fn,\n      \"the first parameter to `createCache` must be a function\"\n    );\n    return new TrackingCache(fn);\n  }\n\n  // src/autotrackMemoize/tracking.ts\n  var neverEq = (a, b) => false;\n  function createTag() {\n    return createCell(null, neverEq);\n  }\n  function dirtyTag(tag, value) {\n    setValue(tag, value);\n  }\n  var consumeCollection = (node) => {\n    let tag = node.collectionTag;\n    if (tag === null) {\n      tag = node.collectionTag = createTag();\n    }\n    getValue(tag);\n  };\n  var dirtyCollection = (node) => {\n    const tag = node.collectionTag;\n    if (tag !== null) {\n      dirtyTag(tag, null);\n    }\n  };\n  var nextId = 0;\n  var proto = Object.getPrototypeOf({});\n  var ObjectTreeNode = class {\n    constructor(value) {\n      this.value = value;\n      this.value = value;\n      this.tag.value = value;\n    }\n    proxy = new Proxy(this, objectProxyHandler);\n    tag = createTag();\n    tags = {};\n    children = {};\n    collectionTag = null;\n    id = nextId++;\n  };\n  var objectProxyHandler = {\n    get(node, key) {\n      function calculateResult() {\n        const { value } = node;\n        const childValue = Reflect.get(value, key);\n        if (typeof key === \"symbol\") {\n          return childValue;\n        }\n        if (key in proto) {\n          return childValue;\n        }\n        if (typeof childValue === \"object\" && childValue !== null) {\n          let childNode = node.children[key];\n          if (childNode === void 0) {\n            childNode = node.children[key] = createNode(childValue);\n          }\n          if (childNode.tag) {\n            getValue(childNode.tag);\n          }\n          return childNode.proxy;\n        } else {\n          let tag = node.tags[key];\n          if (tag === void 0) {\n            tag = node.tags[key] = createTag();\n            tag.value = childValue;\n          }\n          getValue(tag);\n          return childValue;\n        }\n      }\n      const res = calculateResult();\n      return res;\n    },\n    ownKeys(node) {\n      consumeCollection(node);\n      return Reflect.ownKeys(node.value);\n    },\n    getOwnPropertyDescriptor(node, prop) {\n      return Reflect.getOwnPropertyDescriptor(node.value, prop);\n    },\n    has(node, prop) {\n      return Reflect.has(node.value, prop);\n    }\n  };\n  var ArrayTreeNode = class {\n    constructor(value) {\n      this.value = value;\n      this.value = value;\n      this.tag.value = value;\n    }\n    proxy = new Proxy([this], arrayProxyHandler);\n    tag = createTag();\n    tags = {};\n    children = {};\n    collectionTag = null;\n    id = nextId++;\n  };\n  var arrayProxyHandler = {\n    get([node], key) {\n      if (key === \"length\") {\n        consumeCollection(node);\n      }\n      return objectProxyHandler.get(node, key);\n    },\n    ownKeys([node]) {\n      return objectProxyHandler.ownKeys(node);\n    },\n    getOwnPropertyDescriptor([node], prop) {\n      return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n    },\n    has([node], prop) {\n      return objectProxyHandler.has(node, prop);\n    }\n  };\n  function createNode(value) {\n    if (Array.isArray(value)) {\n      return new ArrayTreeNode(value);\n    }\n    return new ObjectTreeNode(value);\n  }\n  function updateNode(node, newValue) {\n    const { value, tags, children } = node;\n    node.value = newValue;\n    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n      dirtyCollection(node);\n    } else {\n      if (value !== newValue) {\n        let oldKeysSize = 0;\n        let newKeysSize = 0;\n        let anyKeysAdded = false;\n        for (const _key in value) {\n          oldKeysSize++;\n        }\n        for (const key in newValue) {\n          newKeysSize++;\n          if (!(key in value)) {\n            anyKeysAdded = true;\n            break;\n          }\n        }\n        const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n        if (isDifferent) {\n          dirtyCollection(node);\n        }\n      }\n    }\n    for (const key in tags) {\n      const childValue = value[key];\n      const newChildValue = newValue[key];\n      if (childValue !== newChildValue) {\n        dirtyCollection(node);\n        dirtyTag(tags[key], newChildValue);\n      }\n      if (typeof newChildValue === \"object\" && newChildValue !== null) {\n        delete tags[key];\n      }\n    }\n    for (const key in children) {\n      const childNode = children[key];\n      const newChildValue = newValue[key];\n      const childValue = childNode.value;\n      if (childValue === newChildValue) {\n        continue;\n      } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n        updateNode(childNode, newChildValue);\n      } else {\n        deleteNode(childNode);\n        delete children[key];\n      }\n    }\n  }\n  function deleteNode(node) {\n    if (node.tag) {\n      dirtyTag(node.tag, null);\n    }\n    dirtyCollection(node);\n    for (const key in node.tags) {\n      dirtyTag(node.tags[key], null);\n    }\n    for (const key in node.children) {\n      deleteNode(node.children[key]);\n    }\n  }\n\n  // src/lruMemoize.ts\n  function createSingletonCache(equals) {\n    let entry;\n    return {\n      get(key) {\n        if (entry && equals(entry.key, key)) {\n          return entry.value;\n        }\n        return NOT_FOUND;\n      },\n      put(key, value) {\n        entry = { key, value };\n      },\n      getEntries() {\n        return entry ? [entry] : [];\n      },\n      clear() {\n        entry = void 0;\n      }\n    };\n  }\n  function createLruCache(maxSize, equals) {\n    let entries = [];\n    function get(key) {\n      const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\n      if (cacheIndex > -1) {\n        const entry = entries[cacheIndex];\n        if (cacheIndex > 0) {\n          entries.splice(cacheIndex, 1);\n          entries.unshift(entry);\n        }\n        return entry.value;\n      }\n      return NOT_FOUND;\n    }\n    function put(key, value) {\n      if (get(key) === NOT_FOUND) {\n        entries.unshift({ key, value });\n        if (entries.length > maxSize) {\n          entries.pop();\n        }\n      }\n    }\n    function getEntries() {\n      return entries;\n    }\n    function clear() {\n      entries = [];\n    }\n    return { get, put, getEntries, clear };\n  }\n  var referenceEqualityCheck = (a, b) => a === b;\n  function createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n      if (prev === null || next === null || prev.length !== next.length) {\n        return false;\n      }\n      const { length } = prev;\n      for (let i = 0; i < length; i++) {\n        if (!equalityCheck(prev[i], next[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n  function lruMemoize(func, equalityCheckOrOptions) {\n    const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\n    const {\n      equalityCheck = referenceEqualityCheck,\n      maxSize = 1,\n      resultEqualityCheck\n    } = providedOptions;\n    const comparator = createCacheKeyComparator(equalityCheck);\n    let resultsCount = 0;\n    const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n    function memoized() {\n      let value = cache.get(arguments);\n      if (value === NOT_FOUND) {\n        value = func.apply(null, arguments);\n        resultsCount++;\n        if (resultEqualityCheck) {\n          const entries = cache.getEntries();\n          const matchingEntry = entries.find(\n            (entry) => resultEqualityCheck(entry.value, value)\n          );\n          if (matchingEntry) {\n            value = matchingEntry.value;\n            resultsCount !== 0 && resultsCount--;\n          }\n        }\n        cache.put(arguments, value);\n      }\n      return value;\n    }\n    memoized.clearCache = () => {\n      cache.clear();\n      memoized.resetResultsCount();\n    };\n    memoized.resultsCount = () => resultsCount;\n    memoized.resetResultsCount = () => {\n      resultsCount = 0;\n    };\n    return memoized;\n  }\n\n  // src/autotrackMemoize/autotrackMemoize.ts\n  function autotrackMemoize(func) {\n    const node = createNode(\n      []\n    );\n    let lastArgs = null;\n    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n    const cache = createCache(() => {\n      const res = func.apply(null, node.proxy);\n      return res;\n    });\n    function memoized() {\n      if (!shallowEqual(lastArgs, arguments)) {\n        updateNode(node, arguments);\n        lastArgs = arguments;\n      }\n      return cache.value;\n    }\n    memoized.clearCache = () => {\n      return cache.clear();\n    };\n    return memoized;\n  }\n\n  // src/weakMapMemoize.ts\n  var StrongRef = class {\n    constructor(value) {\n      this.value = value;\n    }\n    deref() {\n      return this.value;\n    }\n  };\n  var Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\n  var UNTERMINATED = 0;\n  var TERMINATED = 1;\n  function createCacheNode() {\n    return {\n      s: UNTERMINATED,\n      v: void 0,\n      o: null,\n      p: null\n    };\n  }\n  function weakMapMemoize(func, options = {}) {\n    let fnNode = createCacheNode();\n    const { resultEqualityCheck } = options;\n    let lastResult;\n    let resultsCount = 0;\n    function memoized() {\n      let cacheNode = fnNode;\n      const { length } = arguments;\n      for (let i = 0, l = length; i < l; i++) {\n        const arg = arguments[i];\n        if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n          let objectCache = cacheNode.o;\n          if (objectCache === null) {\n            cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n          }\n          const objectNode = objectCache.get(arg);\n          if (objectNode === void 0) {\n            cacheNode = createCacheNode();\n            objectCache.set(arg, cacheNode);\n          } else {\n            cacheNode = objectNode;\n          }\n        } else {\n          let primitiveCache = cacheNode.p;\n          if (primitiveCache === null) {\n            cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n          }\n          const primitiveNode = primitiveCache.get(arg);\n          if (primitiveNode === void 0) {\n            cacheNode = createCacheNode();\n            primitiveCache.set(arg, cacheNode);\n          } else {\n            cacheNode = primitiveNode;\n          }\n        }\n      }\n      const terminatedNode = cacheNode;\n      let result;\n      if (cacheNode.s === TERMINATED) {\n        result = cacheNode.v;\n      } else {\n        result = func.apply(null, arguments);\n        resultsCount++;\n        if (resultEqualityCheck) {\n          const lastResultValue = lastResult?.deref?.() ?? lastResult;\n          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n            result = lastResultValue;\n            resultsCount !== 0 && resultsCount--;\n          }\n          const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n          lastResult = needsWeakRef ? new Ref(result) : result;\n        }\n      }\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    }\n    memoized.clearCache = () => {\n      fnNode = createCacheNode();\n      memoized.resetResultsCount();\n    };\n    memoized.resultsCount = () => resultsCount;\n    memoized.resetResultsCount = () => {\n      resultsCount = 0;\n    };\n    return memoized;\n  }\n\n  // src/createSelectorCreator.ts\n  function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\n    const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n      memoize: memoizeOrOptions,\n      memoizeOptions: memoizeOptionsFromArgs\n    } : memoizeOrOptions;\n    const createSelector2 = (...createSelectorArgs) => {\n      let recomputations = 0;\n      let dependencyRecomputations = 0;\n      let lastResult;\n      let directlyPassedOptions = {};\n      let resultFunc = createSelectorArgs.pop();\n      if (typeof resultFunc === \"object\") {\n        directlyPassedOptions = resultFunc;\n        resultFunc = createSelectorArgs.pop();\n      }\n      assertIsFunction(\n        resultFunc,\n        `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n      );\n      const combinedOptions = {\n        ...createSelectorCreatorOptions,\n        ...directlyPassedOptions\n      };\n      const {\n        memoize,\n        memoizeOptions = [],\n        argsMemoize = weakMapMemoize,\n        argsMemoizeOptions = []} = combinedOptions;\n      const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n      const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n      const dependencies = getDependencies(createSelectorArgs);\n      const memoizedResultFunc = memoize(function recomputationWrapper() {\n        recomputations++;\n        return resultFunc.apply(\n          null,\n          arguments\n        );\n      }, ...finalMemoizeOptions);\n      const selector = argsMemoize(function dependenciesChecker() {\n        dependencyRecomputations++;\n        const inputSelectorResults = collectInputSelectorResults(\n          dependencies,\n          arguments\n        );\n        lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n        return lastResult;\n      }, ...finalArgsMemoizeOptions);\n      return Object.assign(selector, {\n        resultFunc,\n        memoizedResultFunc,\n        dependencies,\n        dependencyRecomputations: () => dependencyRecomputations,\n        resetDependencyRecomputations: () => {\n          dependencyRecomputations = 0;\n        },\n        lastResult: () => lastResult,\n        recomputations: () => recomputations,\n        resetRecomputations: () => {\n          recomputations = 0;\n        },\n        memoize,\n        argsMemoize\n      });\n    };\n    Object.assign(createSelector2, {\n      withTypes: () => createSelector2\n    });\n    return createSelector2;\n  }\n  var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n\n  // src/createStructuredSelector.ts\n  var createStructuredSelector = Object.assign(\n    (inputSelectorsObject, selectorCreator = createSelector) => {\n      assertIsObject(\n        inputSelectorsObject,\n        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n      );\n      const inputSelectorKeys = Object.keys(inputSelectorsObject);\n      const dependencies = inputSelectorKeys.map(\n        (key) => inputSelectorsObject[key]\n      );\n      const structuredSelector = selectorCreator(\n        dependencies,\n        (...inputSelectorResults) => {\n          return inputSelectorResults.reduce((composition, value, index) => {\n            composition[inputSelectorKeys[index]] = value;\n            return composition;\n          }, {});\n        }\n      );\n      return structuredSelector;\n    },\n    { withTypes: () => createStructuredSelector }\n  );\n\n  const __esModule = true ;\n\n  exports.__esModule = __esModule;\n  exports.createSelector = createSelector;\n  exports.createSelectorCreator = createSelectorCreator;\n  exports.createStructuredSelector = createStructuredSelector;\n  exports.lruMemoize = lruMemoize;\n  exports.referenceEqualityCheck = referenceEqualityCheck;\n  exports.setGlobalDevModeChecks = setGlobalDevModeChecks;\n  exports.unstable_autotrackMemoize = autotrackMemoize;\n  exports.weakMapMemoize = weakMapMemoize;\n\n}));\n",
      "relatedPaths": [
        "C:\\Users\\Adrians\\Documents\\sapui5_apps\\sapui5_redux_github\\sapui5_Redux\\node_modules\\reselect\\dist\\reselect.mjs"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false
    }
  ]
}