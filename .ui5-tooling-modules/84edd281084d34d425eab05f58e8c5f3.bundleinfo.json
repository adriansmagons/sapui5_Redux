{
  "_entries": [
    {
      "name": "redux",
      "path": "/Users/C5262046/work/interns/sapui5_Redux/node_modules/redux/dist/redux.mjs",
      "lastModified": 1747315354361,
      "type": "module",
      "originalName": "redux",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  // src/utils/formatProdErrorMessage.ts\n  function formatProdErrorMessage(code) {\n    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n  }\n\n  // src/utils/symbol-observable.ts\n  var $$observable = /* @__PURE__ */ (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\n  var symbol_observable_default = $$observable;\n\n  // src/utils/actionTypes.ts\n  var randomString = () => Math.random().toString(36).substring(7).split(\"\").join(\".\");\n  var ActionTypes = {\n    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,\n    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,\n    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n  };\n  var actionTypes_default = ActionTypes;\n\n  // src/utils/isPlainObject.ts\n  function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null)\n      return false;\n    let proto = obj;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n  }\n\n  // src/createStore.ts\n  function createStore(reducer, preloadedState, enhancer) {\n    if (typeof reducer !== \"function\") {\n      throw new Error(formatProdErrorMessage(2) );\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n      throw new Error(formatProdErrorMessage(0) );\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n      enhancer = preloadedState;\n      preloadedState = void 0;\n    }\n    if (typeof enhancer !== \"undefined\") {\n      if (typeof enhancer !== \"function\") {\n        throw new Error(formatProdErrorMessage(1) );\n      }\n      return enhancer(createStore)(reducer, preloadedState);\n    }\n    let currentReducer = reducer;\n    let currentState = preloadedState;\n    let currentListeners = /* @__PURE__ */ new Map();\n    let nextListeners = currentListeners;\n    let listenerIdCounter = 0;\n    let isDispatching = false;\n    function ensureCanMutateNextListeners() {\n      if (nextListeners === currentListeners) {\n        nextListeners = /* @__PURE__ */ new Map();\n        currentListeners.forEach((listener, key) => {\n          nextListeners.set(key, listener);\n        });\n      }\n    }\n    function getState() {\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(3) );\n      }\n      return currentState;\n    }\n    function subscribe(listener) {\n      if (typeof listener !== \"function\") {\n        throw new Error(formatProdErrorMessage(4) );\n      }\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(5) );\n      }\n      let isSubscribed = true;\n      ensureCanMutateNextListeners();\n      const listenerId = listenerIdCounter++;\n      nextListeners.set(listenerId, listener);\n      return function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n        if (isDispatching) {\n          throw new Error(formatProdErrorMessage(6) );\n        }\n        isSubscribed = false;\n        ensureCanMutateNextListeners();\n        nextListeners.delete(listenerId);\n        currentListeners = null;\n      };\n    }\n    function dispatch(action) {\n      if (!isPlainObject(action)) {\n        throw new Error(formatProdErrorMessage(7) );\n      }\n      if (typeof action.type === \"undefined\") {\n        throw new Error(formatProdErrorMessage(8) );\n      }\n      if (typeof action.type !== \"string\") {\n        throw new Error(formatProdErrorMessage(17) );\n      }\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(9) );\n      }\n      try {\n        isDispatching = true;\n        currentState = currentReducer(currentState, action);\n      } finally {\n        isDispatching = false;\n      }\n      const listeners = currentListeners = nextListeners;\n      listeners.forEach((listener) => {\n        listener();\n      });\n      return action;\n    }\n    function replaceReducer(nextReducer) {\n      if (typeof nextReducer !== \"function\") {\n        throw new Error(formatProdErrorMessage(10) );\n      }\n      currentReducer = nextReducer;\n      dispatch({\n        type: actionTypes_default.REPLACE\n      });\n    }\n    function observable() {\n      const outerSubscribe = subscribe;\n      return {\n        /**\n         * The minimal observable subscription method.\n         * @param observer Any object that can be used as an observer.\n         * The observer object should have a `next` method.\n         * @returns An object with an `unsubscribe` method that can\n         * be used to unsubscribe the observable from the store, and prevent further\n         * emission of values from the observable.\n         */\n        subscribe(observer) {\n          if (typeof observer !== \"object\" || observer === null) {\n            throw new Error(formatProdErrorMessage(11) );\n          }\n          function observeState() {\n            const observerAsObserver = observer;\n            if (observerAsObserver.next) {\n              observerAsObserver.next(getState());\n            }\n          }\n          observeState();\n          const unsubscribe = outerSubscribe(observeState);\n          return {\n            unsubscribe\n          };\n        },\n        [symbol_observable_default]() {\n          return this;\n        }\n      };\n    }\n    dispatch({\n      type: actionTypes_default.INIT\n    });\n    const store = {\n      dispatch,\n      subscribe,\n      getState,\n      replaceReducer,\n      [symbol_observable_default]: observable\n    };\n    return store;\n  }\n  function legacy_createStore(reducer, preloadedState, enhancer) {\n    return createStore(reducer, preloadedState, enhancer);\n  }\n  function assertReducerShape(reducers) {\n    Object.keys(reducers).forEach((key) => {\n      const reducer = reducers[key];\n      const initialState = reducer(void 0, {\n        type: actionTypes_default.INIT\n      });\n      if (typeof initialState === \"undefined\") {\n        throw new Error(formatProdErrorMessage(12) );\n      }\n      if (typeof reducer(void 0, {\n        type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n      }) === \"undefined\") {\n        throw new Error(formatProdErrorMessage(13) );\n      }\n    });\n  }\n  function combineReducers(reducers) {\n    const reducerKeys = Object.keys(reducers);\n    const finalReducers = {};\n    for (let i = 0; i < reducerKeys.length; i++) {\n      const key = reducerKeys[i];\n      if (typeof reducers[key] === \"function\") {\n        finalReducers[key] = reducers[key];\n      }\n    }\n    const finalReducerKeys = Object.keys(finalReducers);\n    let shapeAssertionError;\n    try {\n      assertReducerShape(finalReducers);\n    } catch (e) {\n      shapeAssertionError = e;\n    }\n    return function combination(state = {}, action) {\n      if (shapeAssertionError) {\n        throw shapeAssertionError;\n      }\n      let hasChanged = false;\n      const nextState = {};\n      for (let i = 0; i < finalReducerKeys.length; i++) {\n        const key = finalReducerKeys[i];\n        const reducer = finalReducers[key];\n        const previousStateForKey = state[key];\n        const nextStateForKey = reducer(previousStateForKey, action);\n        if (typeof nextStateForKey === \"undefined\") {\n          action && action.type;\n          throw new Error(formatProdErrorMessage(14) );\n        }\n        nextState[key] = nextStateForKey;\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n      }\n      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n      return hasChanged ? nextState : state;\n    };\n  }\n\n  // src/bindActionCreators.ts\n  function bindActionCreator(actionCreator, dispatch) {\n    return function(...args) {\n      return dispatch(actionCreator.apply(this, args));\n    };\n  }\n  function bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n      return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n      throw new Error(formatProdErrorMessage(16) );\n    }\n    const boundActionCreators = {};\n    for (const key in actionCreators) {\n      const actionCreator = actionCreators[key];\n      if (typeof actionCreator === \"function\") {\n        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n      }\n    }\n    return boundActionCreators;\n  }\n\n  // src/compose.ts\n  function compose(...funcs) {\n    if (funcs.length === 0) {\n      return (arg) => arg;\n    }\n    if (funcs.length === 1) {\n      return funcs[0];\n    }\n    return funcs.reduce((a, b) => (...args) => a(b(...args)));\n  }\n\n  // src/applyMiddleware.ts\n  function applyMiddleware(...middlewares) {\n    return (createStore2) => (reducer, preloadedState) => {\n      const store = createStore2(reducer, preloadedState);\n      let dispatch = () => {\n        throw new Error(formatProdErrorMessage(15) );\n      };\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (action, ...args) => dispatch(action, ...args)\n      };\n      const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n      dispatch = compose(...chain)(store.dispatch);\n      return {\n        ...store,\n        dispatch\n      };\n    };\n  }\n\n  // src/utils/isAction.ts\n  function isAction(action) {\n    return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n  }\n\n  const __esModule = true ;\n\n  exports.__DO_NOT_USE__ActionTypes = actionTypes_default;\n  exports.__esModule = __esModule;\n  exports.applyMiddleware = applyMiddleware;\n  exports.bindActionCreators = bindActionCreators;\n  exports.combineReducers = combineReducers;\n  exports.compose = compose;\n  exports.createStore = createStore;\n  exports.isAction = isAction;\n  exports.isPlainObject = isPlainObject;\n  exports.legacy_createStore = legacy_createStore;\n\n}));\n",
      "relatedPaths": [
        "/Users/C5262046/work/interns/sapui5_Redux/node_modules/redux/dist/redux.mjs"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false
    },
    {
      "name": "reselect",
      "path": "/Users/C5262046/work/interns/sapui5_Redux/node_modules/reselect/dist/reselect.mjs",
      "lastModified": 1747315354495,
      "type": "module",
      "originalName": "reselect",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  // src/devModeChecks/identityFunctionCheck.ts\n\n  // src/devModeChecks/setGlobalDevModeChecks.ts\n  var globalDevModeChecks = {\n    inputStabilityCheck: \"once\",\n    identityFunctionCheck: \"once\"\n  };\n  var setGlobalDevModeChecks = (devModeChecks) => {\n    Object.assign(globalDevModeChecks, devModeChecks);\n  };\n\n  // src/utils.ts\n  var NOT_FOUND = /* @__PURE__ */ Symbol(\"NOT_FOUND\");\n  function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\n    if (typeof func !== \"function\") {\n      throw new TypeError(errorMessage);\n    }\n  }\n  function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\n    if (typeof object !== \"object\") {\n      throw new TypeError(errorMessage);\n    }\n  }\n  function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\n    if (!array.every((item) => typeof item === \"function\")) {\n      const itemTypes = array.map(\n        (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\n      ).join(\", \");\n      throw new TypeError(`${errorMessage}[${itemTypes}]`);\n    }\n  }\n  var ensureIsArray = (item) => {\n    return Array.isArray(item) ? item : [item];\n  };\n  function getDependencies(createSelectorArgs) {\n    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n    assertIsArrayOfFunctions(\n      dependencies,\n      `createSelector expects all input-selectors to be functions, but received the following types: `\n    );\n    return dependencies;\n  }\n  function collectInputSelectorResults(dependencies, inputSelectorArgs) {\n    const inputSelectorResults = [];\n    const { length } = dependencies;\n    for (let i = 0; i < length; i++) {\n      inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n    }\n    return inputSelectorResults;\n  }\n\n  // src/autotrackMemoize/autotracking.ts\n  var $REVISION = 0;\n  var CURRENT_TRACKER = null;\n  var Cell = class {\n    revision = $REVISION;\n    _value;\n    _lastValue;\n    _isEqual = tripleEq;\n    constructor(initialValue, isEqual = tripleEq) {\n      this._value = this._lastValue = initialValue;\n      this._isEqual = isEqual;\n    }\n    // Whenever a storage value is read, it'll add itself to the current tracker if\n    // one exists, entangling its state with that cache.\n    get value() {\n      CURRENT_TRACKER?.add(this);\n      return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    set value(newValue) {\n      if (this.value === newValue)\n        return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  };\n  function tripleEq(a, b) {\n    return a === b;\n  }\n  var TrackingCache = class {\n    _cachedValue;\n    _cachedRevision = -1;\n    _deps = [];\n    hits = 0;\n    fn;\n    constructor(fn) {\n      this.fn = fn;\n    }\n    clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n    get value() {\n      if (this.revision > this._cachedRevision) {\n        const { fn } = this;\n        const currentTracker = /* @__PURE__ */ new Set();\n        const prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n      CURRENT_TRACKER?.add(this);\n      return this._cachedValue;\n    }\n    get revision() {\n      return Math.max(...this._deps.map((d) => d.revision), 0);\n    }\n  };\n  function getValue(cell) {\n    if (!(cell instanceof Cell)) {\n      console.warn(\"Not a valid cell! \", cell);\n    }\n    return cell.value;\n  }\n  function setValue(storage, value) {\n    if (!(storage instanceof Cell)) {\n      throw new TypeError(\n        \"setValue must be passed a tracked store created with `createStorage`.\"\n      );\n    }\n    storage.value = storage._lastValue = value;\n  }\n  function createCell(initialValue, isEqual = tripleEq) {\n    return new Cell(initialValue, isEqual);\n  }\n  function createCache(fn) {\n    assertIsFunction(\n      fn,\n      \"the first parameter to `createCache` must be a function\"\n    );\n    return new TrackingCache(fn);\n  }\n\n  // src/autotrackMemoize/tracking.ts\n  var neverEq = (a, b) => false;\n  function createTag() {\n    return createCell(null, neverEq);\n  }\n  function dirtyTag(tag, value) {\n    setValue(tag, value);\n  }\n  var consumeCollection = (node) => {\n    let tag = node.collectionTag;\n    if (tag === null) {\n      tag = node.collectionTag = createTag();\n    }\n    getValue(tag);\n  };\n  var dirtyCollection = (node) => {\n    const tag = node.collectionTag;\n    if (tag !== null) {\n      dirtyTag(tag, null);\n    }\n  };\n  var nextId = 0;\n  var proto = Object.getPrototypeOf({});\n  var ObjectTreeNode = class {\n    constructor(value) {\n      this.value = value;\n      this.value = value;\n      this.tag.value = value;\n    }\n    proxy = new Proxy(this, objectProxyHandler);\n    tag = createTag();\n    tags = {};\n    children = {};\n    collectionTag = null;\n    id = nextId++;\n  };\n  var objectProxyHandler = {\n    get(node, key) {\n      function calculateResult() {\n        const { value } = node;\n        const childValue = Reflect.get(value, key);\n        if (typeof key === \"symbol\") {\n          return childValue;\n        }\n        if (key in proto) {\n          return childValue;\n        }\n        if (typeof childValue === \"object\" && childValue !== null) {\n          let childNode = node.children[key];\n          if (childNode === void 0) {\n            childNode = node.children[key] = createNode(childValue);\n          }\n          if (childNode.tag) {\n            getValue(childNode.tag);\n          }\n          return childNode.proxy;\n        } else {\n          let tag = node.tags[key];\n          if (tag === void 0) {\n            tag = node.tags[key] = createTag();\n            tag.value = childValue;\n          }\n          getValue(tag);\n          return childValue;\n        }\n      }\n      const res = calculateResult();\n      return res;\n    },\n    ownKeys(node) {\n      consumeCollection(node);\n      return Reflect.ownKeys(node.value);\n    },\n    getOwnPropertyDescriptor(node, prop) {\n      return Reflect.getOwnPropertyDescriptor(node.value, prop);\n    },\n    has(node, prop) {\n      return Reflect.has(node.value, prop);\n    }\n  };\n  var ArrayTreeNode = class {\n    constructor(value) {\n      this.value = value;\n      this.value = value;\n      this.tag.value = value;\n    }\n    proxy = new Proxy([this], arrayProxyHandler);\n    tag = createTag();\n    tags = {};\n    children = {};\n    collectionTag = null;\n    id = nextId++;\n  };\n  var arrayProxyHandler = {\n    get([node], key) {\n      if (key === \"length\") {\n        consumeCollection(node);\n      }\n      return objectProxyHandler.get(node, key);\n    },\n    ownKeys([node]) {\n      return objectProxyHandler.ownKeys(node);\n    },\n    getOwnPropertyDescriptor([node], prop) {\n      return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n    },\n    has([node], prop) {\n      return objectProxyHandler.has(node, prop);\n    }\n  };\n  function createNode(value) {\n    if (Array.isArray(value)) {\n      return new ArrayTreeNode(value);\n    }\n    return new ObjectTreeNode(value);\n  }\n  function updateNode(node, newValue) {\n    const { value, tags, children } = node;\n    node.value = newValue;\n    if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n      dirtyCollection(node);\n    } else {\n      if (value !== newValue) {\n        let oldKeysSize = 0;\n        let newKeysSize = 0;\n        let anyKeysAdded = false;\n        for (const _key in value) {\n          oldKeysSize++;\n        }\n        for (const key in newValue) {\n          newKeysSize++;\n          if (!(key in value)) {\n            anyKeysAdded = true;\n            break;\n          }\n        }\n        const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n        if (isDifferent) {\n          dirtyCollection(node);\n        }\n      }\n    }\n    for (const key in tags) {\n      const childValue = value[key];\n      const newChildValue = newValue[key];\n      if (childValue !== newChildValue) {\n        dirtyCollection(node);\n        dirtyTag(tags[key], newChildValue);\n      }\n      if (typeof newChildValue === \"object\" && newChildValue !== null) {\n        delete tags[key];\n      }\n    }\n    for (const key in children) {\n      const childNode = children[key];\n      const newChildValue = newValue[key];\n      const childValue = childNode.value;\n      if (childValue === newChildValue) {\n        continue;\n      } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n        updateNode(childNode, newChildValue);\n      } else {\n        deleteNode(childNode);\n        delete children[key];\n      }\n    }\n  }\n  function deleteNode(node) {\n    if (node.tag) {\n      dirtyTag(node.tag, null);\n    }\n    dirtyCollection(node);\n    for (const key in node.tags) {\n      dirtyTag(node.tags[key], null);\n    }\n    for (const key in node.children) {\n      deleteNode(node.children[key]);\n    }\n  }\n\n  // src/lruMemoize.ts\n  function createSingletonCache(equals) {\n    let entry;\n    return {\n      get(key) {\n        if (entry && equals(entry.key, key)) {\n          return entry.value;\n        }\n        return NOT_FOUND;\n      },\n      put(key, value) {\n        entry = { key, value };\n      },\n      getEntries() {\n        return entry ? [entry] : [];\n      },\n      clear() {\n        entry = void 0;\n      }\n    };\n  }\n  function createLruCache(maxSize, equals) {\n    let entries = [];\n    function get(key) {\n      const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\n      if (cacheIndex > -1) {\n        const entry = entries[cacheIndex];\n        if (cacheIndex > 0) {\n          entries.splice(cacheIndex, 1);\n          entries.unshift(entry);\n        }\n        return entry.value;\n      }\n      return NOT_FOUND;\n    }\n    function put(key, value) {\n      if (get(key) === NOT_FOUND) {\n        entries.unshift({ key, value });\n        if (entries.length > maxSize) {\n          entries.pop();\n        }\n      }\n    }\n    function getEntries() {\n      return entries;\n    }\n    function clear() {\n      entries = [];\n    }\n    return { get, put, getEntries, clear };\n  }\n  var referenceEqualityCheck = (a, b) => a === b;\n  function createCacheKeyComparator(equalityCheck) {\n    return function areArgumentsShallowlyEqual(prev, next) {\n      if (prev === null || next === null || prev.length !== next.length) {\n        return false;\n      }\n      const { length } = prev;\n      for (let i = 0; i < length; i++) {\n        if (!equalityCheck(prev[i], next[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n  function lruMemoize(func, equalityCheckOrOptions) {\n    const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\n    const {\n      equalityCheck = referenceEqualityCheck,\n      maxSize = 1,\n      resultEqualityCheck\n    } = providedOptions;\n    const comparator = createCacheKeyComparator(equalityCheck);\n    let resultsCount = 0;\n    const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n    function memoized() {\n      let value = cache.get(arguments);\n      if (value === NOT_FOUND) {\n        value = func.apply(null, arguments);\n        resultsCount++;\n        if (resultEqualityCheck) {\n          const entries = cache.getEntries();\n          const matchingEntry = entries.find(\n            (entry) => resultEqualityCheck(entry.value, value)\n          );\n          if (matchingEntry) {\n            value = matchingEntry.value;\n            resultsCount !== 0 && resultsCount--;\n          }\n        }\n        cache.put(arguments, value);\n      }\n      return value;\n    }\n    memoized.clearCache = () => {\n      cache.clear();\n      memoized.resetResultsCount();\n    };\n    memoized.resultsCount = () => resultsCount;\n    memoized.resetResultsCount = () => {\n      resultsCount = 0;\n    };\n    return memoized;\n  }\n\n  // src/autotrackMemoize/autotrackMemoize.ts\n  function autotrackMemoize(func) {\n    const node = createNode(\n      []\n    );\n    let lastArgs = null;\n    const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n    const cache = createCache(() => {\n      const res = func.apply(null, node.proxy);\n      return res;\n    });\n    function memoized() {\n      if (!shallowEqual(lastArgs, arguments)) {\n        updateNode(node, arguments);\n        lastArgs = arguments;\n      }\n      return cache.value;\n    }\n    memoized.clearCache = () => {\n      return cache.clear();\n    };\n    return memoized;\n  }\n\n  // src/weakMapMemoize.ts\n  var StrongRef = class {\n    constructor(value) {\n      this.value = value;\n    }\n    deref() {\n      return this.value;\n    }\n  };\n  var Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\n  var UNTERMINATED = 0;\n  var TERMINATED = 1;\n  function createCacheNode() {\n    return {\n      s: UNTERMINATED,\n      v: void 0,\n      o: null,\n      p: null\n    };\n  }\n  function weakMapMemoize(func, options = {}) {\n    let fnNode = createCacheNode();\n    const { resultEqualityCheck } = options;\n    let lastResult;\n    let resultsCount = 0;\n    function memoized() {\n      let cacheNode = fnNode;\n      const { length } = arguments;\n      for (let i = 0, l = length; i < l; i++) {\n        const arg = arguments[i];\n        if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n          let objectCache = cacheNode.o;\n          if (objectCache === null) {\n            cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n          }\n          const objectNode = objectCache.get(arg);\n          if (objectNode === void 0) {\n            cacheNode = createCacheNode();\n            objectCache.set(arg, cacheNode);\n          } else {\n            cacheNode = objectNode;\n          }\n        } else {\n          let primitiveCache = cacheNode.p;\n          if (primitiveCache === null) {\n            cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n          }\n          const primitiveNode = primitiveCache.get(arg);\n          if (primitiveNode === void 0) {\n            cacheNode = createCacheNode();\n            primitiveCache.set(arg, cacheNode);\n          } else {\n            cacheNode = primitiveNode;\n          }\n        }\n      }\n      const terminatedNode = cacheNode;\n      let result;\n      if (cacheNode.s === TERMINATED) {\n        result = cacheNode.v;\n      } else {\n        result = func.apply(null, arguments);\n        resultsCount++;\n        if (resultEqualityCheck) {\n          const lastResultValue = lastResult?.deref?.() ?? lastResult;\n          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n            result = lastResultValue;\n            resultsCount !== 0 && resultsCount--;\n          }\n          const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n          lastResult = needsWeakRef ? new Ref(result) : result;\n        }\n      }\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    }\n    memoized.clearCache = () => {\n      fnNode = createCacheNode();\n      memoized.resetResultsCount();\n    };\n    memoized.resultsCount = () => resultsCount;\n    memoized.resetResultsCount = () => {\n      resultsCount = 0;\n    };\n    return memoized;\n  }\n\n  // src/createSelectorCreator.ts\n  function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\n    const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n      memoize: memoizeOrOptions,\n      memoizeOptions: memoizeOptionsFromArgs\n    } : memoizeOrOptions;\n    const createSelector2 = (...createSelectorArgs) => {\n      let recomputations = 0;\n      let dependencyRecomputations = 0;\n      let lastResult;\n      let directlyPassedOptions = {};\n      let resultFunc = createSelectorArgs.pop();\n      if (typeof resultFunc === \"object\") {\n        directlyPassedOptions = resultFunc;\n        resultFunc = createSelectorArgs.pop();\n      }\n      assertIsFunction(\n        resultFunc,\n        `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n      );\n      const combinedOptions = {\n        ...createSelectorCreatorOptions,\n        ...directlyPassedOptions\n      };\n      const {\n        memoize,\n        memoizeOptions = [],\n        argsMemoize = weakMapMemoize,\n        argsMemoizeOptions = []} = combinedOptions;\n      const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n      const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n      const dependencies = getDependencies(createSelectorArgs);\n      const memoizedResultFunc = memoize(function recomputationWrapper() {\n        recomputations++;\n        return resultFunc.apply(\n          null,\n          arguments\n        );\n      }, ...finalMemoizeOptions);\n      const selector = argsMemoize(function dependenciesChecker() {\n        dependencyRecomputations++;\n        const inputSelectorResults = collectInputSelectorResults(\n          dependencies,\n          arguments\n        );\n        lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n        return lastResult;\n      }, ...finalArgsMemoizeOptions);\n      return Object.assign(selector, {\n        resultFunc,\n        memoizedResultFunc,\n        dependencies,\n        dependencyRecomputations: () => dependencyRecomputations,\n        resetDependencyRecomputations: () => {\n          dependencyRecomputations = 0;\n        },\n        lastResult: () => lastResult,\n        recomputations: () => recomputations,\n        resetRecomputations: () => {\n          recomputations = 0;\n        },\n        memoize,\n        argsMemoize\n      });\n    };\n    Object.assign(createSelector2, {\n      withTypes: () => createSelector2\n    });\n    return createSelector2;\n  }\n  var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n\n  // src/createStructuredSelector.ts\n  var createStructuredSelector = Object.assign(\n    (inputSelectorsObject, selectorCreator = createSelector) => {\n      assertIsObject(\n        inputSelectorsObject,\n        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n      );\n      const inputSelectorKeys = Object.keys(inputSelectorsObject);\n      const dependencies = inputSelectorKeys.map(\n        (key) => inputSelectorsObject[key]\n      );\n      const structuredSelector = selectorCreator(\n        dependencies,\n        (...inputSelectorResults) => {\n          return inputSelectorResults.reduce((composition, value, index) => {\n            composition[inputSelectorKeys[index]] = value;\n            return composition;\n          }, {});\n        }\n      );\n      return structuredSelector;\n    },\n    { withTypes: () => createStructuredSelector }\n  );\n\n  const __esModule = true ;\n\n  exports.__esModule = __esModule;\n  exports.createSelector = createSelector;\n  exports.createSelectorCreator = createSelectorCreator;\n  exports.createStructuredSelector = createStructuredSelector;\n  exports.lruMemoize = lruMemoize;\n  exports.referenceEqualityCheck = referenceEqualityCheck;\n  exports.setGlobalDevModeChecks = setGlobalDevModeChecks;\n  exports.unstable_autotrackMemoize = autotrackMemoize;\n  exports.weakMapMemoize = weakMapMemoize;\n\n}));\n",
      "relatedPaths": [
        "/Users/C5262046/work/interns/sapui5_Redux/node_modules/reselect/dist/reselect.mjs"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false
    }
  ]
}